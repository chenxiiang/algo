Java基础
Java 中有哪 8 种基本数据类型？它们的默认值和占用的空间大小知道不？ 说说这 8 种基本数据类型对应的包装类型。
💡 提示：Java 中有 8 种基本数据类型，分别为：
6 种数字类型 ：byte、short、int、long、float、double
1 种字符类型：char
1 种布尔型：boolean。

包装类型的常量池技术了解么？
💡 提示：Java 基本类型的包装类的大部分（Byte,Short,Integer,Long ,Character,Boolean）都实现了常量池技术。
Float和Double没有常量池

🌈 拓展：整型包装类对象之间值的比较应该使用 equals 方法

为什么要有包装类型？

💡 提示： 基本类型有默认值、泛型参数不能是基本类型

什么是自动拆装箱？原理？

💡 提示：基本类型和包装类型之间的互转。装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。

遇到过自动拆箱引发的 NPE 问题吗？

💡 提示：两个常见的场景：

●数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险
●三目运算符使用不当会导致诡异的 NPE 异常 只要一个运算中有不同的类型，涉及到类型转换，则编译器会向下（基本类型）转型，再进行运算。

String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?

💡 提示：可以从可变性、线程安全性、性能这几个角度来回答。

重载和重写的区别？

💡 提示：可以从下面几个角度来回答：

●发生范围  重写发生在运行期 重载发生在编译期
●参数列表
●返回值类型
●异常
●访问修饰符
●发生阶段

== 和 equals() 的区别

💡 提示：== 对于基本类型和引用类型的作用效果是不同的，equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals() 方法存在两种使用情况：

●类没有重写 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。
●类重写了 equals()方法 ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

Java 反射？反射有什么优点/缺点？你是怎么理解反射的（为什么框架需要反射）？springboot怎么利用反射？

💡 提示： 想想你平时使用框架为啥能够如此方便。想想动态代理以及注解和反射之间的关系。

谈谈对 Java 注解的理解，解决了什么问题？

💡 提示： 想想你平时使用框架为啥能够如此方便。另外，需要注意注解的解析依赖于反射机制，务必要提前把反射机制搞懂。

Java 泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？

💡 提示：

●好处：编译期间的类型检测（安全）、可读性更好
●Java 的泛型是伪泛型

泛型的作用：

● 使用泛型可在编译期间进行类型检测。 
● 使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。 
● 泛型可以使用自限定类型如 T extends Comparable 。

泛型的限制一般是由泛型擦除机制导致的。擦除为 Object 后无法进行类型判断

●只能声明不能实例化 T 类型变量。
●泛型参数不能是基本类型。因为基本类型不是 Object 子类，应该用基本类型对应的引用类型代替。
●不能实例化泛型参数的数组。擦除后为 Object 后无法进行类型判断。
●不能实例化泛型数组。（数组必须知道它所持有的元素的具体类型，但是类型擦除违反了数组的这种安全检查的原则）
●泛型无法使用 Instance of 和 getClass() 进行类型判断。
●不能实现两个不同泛型参数的同一接口，擦除后多个父类的桥方法将冲突
●不能使用 static 修饰泛型变量
●......

通配符 ？和常用的泛型 T 之间有什么区别？ T在声明的时候用，？在实例化的时候用

●T 可以用于声明变量或常量而 ? 不行。
●T 一般用于声明泛型类或方法，通配符 ? 一般用于泛型方法的调用代码和形参。
●T 在编译期会被擦除为限定类型或 Object，通配符用于捕获具体类型。

内部类了解吗？匿名内部类了解吗？

内部类分为下面 4 种：
●成员内部类  成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员，因为编译器默认为成员内部类添加了一个指向外部类对象的引用），当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要指定外部类名，外部类.this.成员变量。外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。如果要创建成员内部类的对象，前提是必须存在一个外部类的对象
●静态内部类  有static的成员内部类，不需要依赖于外部类
●局部（方法）内部类  局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
●匿名内部类  一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。在new的时候实现方法

为什么局部内部类和匿名内部类只能访问局部final变量？
因为当方法执行完毕后，局部变量的生命周期也就结束了，但是内部类对象的声明周期可能还没结束，所以内部类会创建一个拷贝（如果局部变量的值在编译期可以确定，则直接在内部类中创建一个拷贝，如果无法确定，则通过构造器传参的方式对拷贝进行初始化赋值），这样解决了声明周期的问题，但是在拷贝时必须保证这两个变量是一样的，如果在内部类的运行中修改了变量的值，则会造成数据不一致，为了解决这个问题，必须限定为final，在对它初始化后就不允许再进行修改，从而保证一致性。

BIO,NIO,AIO 有什么区别?

多态以及多态的底层实现
有 2 种方式来实现多态，一种是编译时多态，另外一种是运行时多态；编译时多态是通过方法的重载来实现的，运行时多态是通过方法的重写来实现的。
1）方法的重载：指的是同一个类中有多个同名的方法，但这些方法有着不同的参数。在编译时就可以确定到底调用哪个方法。
2）方法的重写：子类重写父类中的方法。父类的引用变量不仅可以指向父类的实例对象，还可以指向子类的实例对象。当父类的引用指向子类的对象时，只有在运行时才能确定调用哪个方法。体现出多态、动态链接，向上转型。
3）向上转型：父类对象引用子类对象。
4）动态链接：当父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用； 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。

在编译期间只能通过参数的静态类型进行而非实际类型作为判定依据。但是重写和实现接口的方法，编译期间无法判断，只能在运行时判断。

多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。invokevirtual 和 invokeinterface 用于动态绑定。可以看出，动态绑定主要应用于虚方法(invokevirtual)和接口方法(invokeinterface)。
方法表是动态绑定的核心，也是Java实现动态调用的主要方式，它被存储于方法区中的类型信息。

多态的内存分配过程
1.类的加载
2.实例化子对象，分为this和super两个部分。
this部分包括当前类的实例变量，以及一个指针指向当前类对应的方法区。
super部分包括它的父类的实例变量，以及一个指针指向父类的方法区。
3.用栈内存中的指针变量指向实例对象。

然后invokevirtual在运行时解析会做以下事情：
找到操作数栈顶的第一个元素所指向的对象的实际类型；
如果在该类型（子类）中找到与常量中的描述符和简单名称都相同的方法，进行权限访问，通过则返回这个方法的引用；如果权限访问不通过，则返回java.lang.IllegalAccessError错误。
如果没有找到签名相同的方法，对该类型的父类进行第二步的搜索和验证；
如果没有找到，则返回java.lang.AbstractMethodError.

Java 集合
说说 List,Set,Map 三者的区别？

💡 提示：可以从这些数据结构中的元素是否有序、是否可以重复、存储的元素类型（比如 Map 存储的就是键值对）等方面来回答。

List,Set,Map 在 Java 中分别由哪些对应的实现类？底层的数据结构？

💡 提示：拿 List 来举例， List 的常见实现类以及它们的数据结构 ：

●ArrayList： Object[]数组
●Vector：Object[]数组
●LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)

有哪些集合是线程不安全的？怎么解决呢？

💡 提示：这块比较常问的是 Arraylist 和 Vector（除去线程安全的方面，还有vector扩容时扩展1倍，ArrayList扩展0.5倍） 、HashMap 和 ConcurrentHashMap（高频问题，重要） 。被问到 Vector 的时候， 你紧接着可能会被问到 Arraylist 和 Vector 的区别。被问到 ConcurrentHashMap 的时候，你紧接着就可能会被问到 ConcurrentHashMap 相关的问题比如 ConcurrentHashMap 是如何保证线程安全的。

hashtable,对于null值会抛出异常,而对于null键,则会调用null.hashCode(),而导致空指针异常,而concurrenthashmap则对于null键值对,直接抛出空异常,这也就是为什么他们存入null键值对抛出异常的原因.hashmap在对null键求hash时直接返回0，value也可以为0，但是只能有一个key为0.

为什么不支持null？
ConcurrentHashmap和Hashtable都是线程安全用来做支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。而HashMap是非并发的，可以通过contains(key)来做这个判断。而支持并发的Map在调用m.contains（key）和m.get(key),m很可能已经不同了

HashMap 查询，删除的时间复杂度
💡 提示：理想状态下是O（1），因为对内存来说访问任何地址的时间是一样的，但是要达到理想状态需要很大的空间，所以要在空间和时间进行取舍。
●没有哈希冲突的情况：如果没有碰撞就是理想状态
●转链表的情况：hash的时间是1，最坏情况所有元素在同一个链表，就是O(n)
●链表转红黑树的情况：O(logn)

HashMap 的底层实现
💡 提示：
●JDK1.8 之前 ： 数组和链表
●JDK1.8 之后 ： 多了红黑树

HashMap 的长度为什么是 2 的幂次方
💡 提示：提高运算效率。
前提：为什么要取模？哈希值的范围空间有40亿，不能直接用，要经过取模才能得到数组下标。

答案可以答三点：
1、提高运算效率，根据hashcode求存储位置，就是hashcode%length，特殊情况是如果length是2的n次方，这个取模运算等价于位运算hashcode&(length-1)，是比除法运算快的
2、保证低位所有的位置都可用，2的n次方一定是偶数，减1后的二进制末尾一定是1，这样无论hashcode末尾是0还是1，都可以把内存中末尾是1或0的位置都存储元素，如果不保证2的幂，当长度为奇数时，减1的二进制末尾一定是0，此时内存地址末尾为1的位置永远不会有元素放入，造成空间浪费
3、解决负数问题，hashcode结果是int类型，取值范围是-2^31 ~ 2^31 – 1，对负数取模是比较麻烦的，当使用二进制的位运算时，无论hashcode是正数还是负数，反正length-1一定是正数，那么它的首位一定是0，与运算后结果的首位也一定是0，得到的结果一定是正数。


比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同
💡 提示：
●HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。
●HashSet（基于hashmap的哈希表）、LinkedHashSet（基于linkedhashmap实现的链表和哈希表，linkedhashmap是一个将所有entry节点加入一个双向链表的hashmap） 和 TreeSet（红黑树） 的主要区别在于底层数据结构不同（底层数据结构不同又导致这三者的应用场景不同）。

HashMap 和 Hashtable 的区别？ 多线程、效率、null、初始容量和扩容、底层结构
HashMap 和 HashSet 区别？
HashMap 和 TreeMap 区别？

ConcurrentHashMap 和 Hashtable 的区别？
💡 提示：
●底层数据结构
●实现线程安全的方式的区别

ConcurrentHashMap 线程安全的具体实现方式/底层具体实现
💡 提示：
●JDK 1.7 ：Segment 分段+reentrantlock，每个segment都继承reentrantlock
●JDK 1.8 ： CAS 乐观锁和 synchronized
Cas体现在当数组中当前位置为null，也就是指定位置还没有插入元素时，通过cas来把新node写入数组中对应位置，如果在put的过程中别的线程已经插入了数据导致位置又不为空，则cas失败，返回false，继续寻找位置，整个put的过程不加锁，利用table是volatile的特性。当指定位置不为空时，通过加同步锁来添加节点。而在1.7中，定位到segment后就会把整个segment加锁，即使需要插入的位置暂时是空的，也要加锁。（注意，1.7中如果指定的segment还没有初始化，通过cas来初始化）
注
1.8的锁粒度更小，因为1.7中，segment是根据hashcode的高位来计算的，当segment相同时把整个segment都锁住了，但是它们的hashcode并不一定一样，但是在1.8中取消了segment概念，直接就是node数组，其中的元素就是链表的头结点，锁的时候只锁相同hashcode的头结点，并发度是比1.7的实现更高的。

Java并发
什么是线程和进程?线程与进程的关系,区别及优缺点？⭐⭐⭐⭐
定义
进程：进程是程序处理机上的一次执行过程， 它是一个动态的概念，它是系统进行资源分配和调度的一个独立单位。
线程：进程内部的一个实体，是CPU运行调度的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

关系
一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行；
相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

区别
(1)、地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间；
(2)、资源拥有：同一进程内的线程共享本进程的资源，但是进程之间的资源是独立的；
(3)、一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉，所以多进程要比多线程健壮；
(4)、进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程；
(5)、执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
(6)、线程是处理器调度的基本单位，但是进程不是。


为什么要使用多线程呢? ⭐⭐⭐
💡 提示：从计算机角度来说主要是为了充分利用多核 CPU 和IO的能力，从项目角度来说主要是为了提升系统的性能。

说说线程的生命周期和状态? ⭐⭐⭐⭐
💡 提示： 6 种状态（NEW、RUNNABLE、BLOCKED、WAITING、TIME_WAITING、TERMINATED）。

🌈 拓展：在操作系统中层面线程有 READY 和 RUNNING 状态，而在 JVM 层面只能看到 RUNNABLE 状态。

什么是线程死锁?如何避免死锁?如何预防和避免线程死锁? ⭐⭐⭐⭐
💡 提示： 这里最好能够结合代码来聊，你要确保自己可以写出有死锁问题的代码。
1、预防死锁：破坏死锁产生的条件
2、避免死锁：银行家算法
🌈 拓展：项目中遇到死锁问题是比较常见的，除了要搞懂上面这些死锁的基本概念之外，你还要知道线上项目遇到死锁问题该如何排查和解决。
1、jps+jstack 先查id，再看stack
2、jconsole 可以直接查看
3、jvisualvm
synchronized 关键字 ⭐⭐⭐⭐⭐
💡 提示：synchronized 关键字几乎是面试必问，你需要搞懂下面这些 synchronized 关键字相关的问题：
● synchronized 关键字的作用，自己是怎么使用的。 
● synchronized 关键字的底层原理（重点！！！）  同步代码块（monitorenter monitorexit）和同步方法（ACC_SYNCHRONIZED）加的指令名不一样，但是本质都是对对象监视器monitor的获取
● JDK1.6 之后的 synchronized 关键字底层做了哪些优化。synchronized 锁升级流程。 
 
● synchronized 和 ReentrantLock 的区别。 
都是可重入锁，一个依赖于jvm一个依赖于api，reentrantlock有高级功能，如等待可中断，可选择公平锁还是非公平锁（默认非公平，synchronized只能非公平），还可以给锁绑定条件实现选择性通知
● synchronized 和 volatile 的区别。 
1.	volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2.	volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
3.	volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
4.	volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
5.	volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
JMM中关于synchronized有如下规定，线程加锁时，必须清空工作内存中共享变量的值，从而使用共享变量时需要从主内存重新读取；线程在解锁时，需要把工作内存中最新的共享变量的值写入到主存，以此来保证共享变量的可见性。所以，它可以保证可见性和原子性

还有线程安全的两个方面：执行控制和内存可见
执行控制目的是控制代码执行顺序以及是否可以并发执行
内存可见控制的是线程的执行结果在内存中对其他线程的可见性
synchronized解决的是执行控制的问题，会阻止其他线程获得对象的监控锁，也就无法并发执行，更重要的是synchronized还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都直接刷到内存中，从而保证了可见性
volatile解决的是内存可见性的问题，使得所有对volatile变量的读写都会直接刷到主存，保证了变量的可见性。但是对读取顺序没有任何要求，所以并不能保证原子性。

并发编程的三个重要特性 ⭐⭐⭐⭐⭐ 
💡 提示： 原子性、可见性、有序性
https://cloud.tencent.com/developer/article/1751728

JMM（Java Memory Model，Java 内存模型）和 happens-before 原则。 ⭐⭐⭐⭐⭐

volatile 关键字 ⭐⭐⭐⭐⭐
💡 提示：volatile 关键字同样是一个重点！结合 JMM（Java Memory Model，Java 内存模型）和 happens-before 原则来回答就行了。

ThreadLocal 关键字 ⭐⭐⭐⭐⭐
💡 提示：关注ThreadLocal的底层原理、内存泄露问题以及自己是如何在项目中使用ThreadLocal关键字的。

线程池 ⭐⭐⭐⭐⭐
💡 提示：线程池有哪几种，各种线程池的优缺点，线程池的重要参数、线程池的执行流程、线程池的饱和策略、如何设置线程池的大小等等。

ReentrantLock 和 AQS ⭐⭐⭐⭐⭐
💡 提示： ReentrantLock 的特性、实现原理（基于 AQS）。可以从 ReentrantLock 的实现来理解 AQS。
AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

乐观锁和悲观锁的区别 ⭐⭐⭐⭐⭐

CAS 了解么？原理？什么是 ABA 问题？ABA 问题怎么解决？ ⭐⭐⭐⭐⭐
💡 提示：多地方都用到了 CAS 比如 ConcurrentHashMap 采用 CAS 和 synchronized 来保证并发安全，再比如java.util.concurrent.atomic包中的类通过 volatile+CAS 重试保证线程安全性。和面试官聊 CAS 的时候，你可以结合 CAS 的一些实际应用来说。

Atomic 原子类 ⭐⭐
