Java基础
Java 中有哪 8 种基本数据类型？它们的默认值和占用的空间大小知道不？ 说说这 8 种基本数据类型对应的包装类型。
💡 提示：Java 中有 8 种基本数据类型，分别为：
6 种数字类型 ：byte、short、int、long、float、double
1 种字符类型：char
1 种布尔型：boolean。

包装类型的常量池技术了解么？
💡 提示：Java 基本类型的包装类的大部分（Byte,Short,Integer,Long ,Character,Boolean）都实现了常量池技术。
Float和Double没有常量池

🌈 拓展：整型包装类对象之间值的比较应该使用 equals 方法

为什么要有包装类型？

💡 提示： 基本类型有默认值、泛型参数不能是基本类型

什么是自动拆装箱？原理？

💡 提示：基本类型和包装类型之间的互转。装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。

遇到过自动拆箱引发的 NPE 问题吗？

💡 提示：两个常见的场景：

●数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险
●三目运算符使用不当会导致诡异的 NPE 异常 只要一个运算中有不同的类型，涉及到类型转换，则编译器会向下（基本类型）转型，再进行运算。

String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?

💡 提示：可以从可变性、线程安全性、性能这几个角度来回答。

重载和重写的区别？

💡 提示：可以从下面几个角度来回答：

●发生范围  重写发生在运行期 重载发生在编译期
●参数列表
●返回值类型
●异常
●访问修饰符
●发生阶段

== 和 equals() 的区别

💡 提示：== 对于基本类型和引用类型的作用效果是不同的，equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals() 方法存在两种使用情况：

●类没有重写 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。
●类重写了 equals()方法 ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

Java 反射？反射有什么优点/缺点？你是怎么理解反射的（为什么框架需要反射）？springboot怎么利用反射？

💡 提示： 想想你平时使用框架为啥能够如此方便。想想动态代理以及注解和反射之间的关系。

谈谈对 Java 注解的理解，解决了什么问题？

💡 提示： 想想你平时使用框架为啥能够如此方便。另外，需要注意注解的解析依赖于反射机制，务必要提前把反射机制搞懂。

Java 泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？

💡 提示：

●好处：编译期间的类型检测（安全）、可读性更好
●Java 的泛型是伪泛型

泛型的作用：

● 使用泛型可在编译期间进行类型检测。 
● 使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。 
● 泛型可以使用自限定类型如 T extends Comparable 。

泛型的限制一般是由泛型擦除机制导致的。擦除为 Object 后无法进行类型判断

●只能声明不能实例化 T 类型变量。
●泛型参数不能是基本类型。因为基本类型不是 Object 子类，应该用基本类型对应的引用类型代替。
●不能实例化泛型参数的数组。擦除后为 Object 后无法进行类型判断。
●不能实例化泛型数组。（数组必须知道它所持有的元素的具体类型，但是类型擦除违反了数组的这种安全检查的原则）
●泛型无法使用 Instance of 和 getClass() 进行类型判断。
●不能实现两个不同泛型参数的同一接口，擦除后多个父类的桥方法将冲突
●不能使用 static 修饰泛型变量
●......

通配符 ？和常用的泛型 T 之间有什么区别？ T在声明的时候用，？在实例化的时候用

●T 可以用于声明变量或常量而 ? 不行。
●T 一般用于声明泛型类或方法，通配符 ? 一般用于泛型方法的调用代码和形参。
●T 在编译期会被擦除为限定类型或 Object，通配符用于捕获具体类型。

内部类了解吗？匿名内部类了解吗？

内部类分为下面 4 种：
●成员内部类  成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员，因为编译器默认为成员内部类添加了一个指向外部类对象的引用），当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要指定外部类名，外部类.this.成员变量。外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。如果要创建成员内部类的对象，前提是必须存在一个外部类的对象
●静态内部类  有static的成员内部类，不需要依赖于外部类
●局部（方法）内部类  局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
●匿名内部类  一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。在new的时候实现方法

为什么局部内部类和匿名内部类只能访问局部final变量？
因为当方法执行完毕后，局部变量的生命周期也就结束了，但是内部类对象的声明周期可能还没结束，所以内部类会创建一个拷贝（如果局部变量的值在编译期可以确定，则直接在内部类中创建一个拷贝，如果无法确定，则通过构造器传参的方式对拷贝进行初始化赋值），这样解决了声明周期的问题，但是在拷贝时必须保证这两个变量是一样的，如果在内部类的运行中修改了变量的值，则会造成数据不一致，为了解决这个问题，必须限定为final，在对它初始化后就不允许再进行修改，从而保证一致性。

BIO,NIO,AIO 有什么区别?

多态以及多态的底层实现
有 2 种方式来实现多态，一种是编译时多态，另外一种是运行时多态；编译时多态是通过方法的重载来实现的，运行时多态是通过方法的重写来实现的。
1）方法的重载：指的是同一个类中有多个同名的方法，但这些方法有着不同的参数。在编译时就可以确定到底调用哪个方法。
2）方法的重写：子类重写父类中的方法。父类的引用变量不仅可以指向父类的实例对象，还可以指向子类的实例对象。当父类的引用指向子类的对象时，只有在运行时才能确定调用哪个方法。体现出多态、动态链接，向上转型。
3）向上转型：父类对象引用子类对象。
4）动态链接：当父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用； 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。

在编译期间只能通过参数的静态类型进行而非实际类型作为判定依据。但是重写和实现接口的方法，编译期间无法判断，只能在运行时判断。

多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。invokevirtual 和 invokeinterface 用于动态绑定。可以看出，动态绑定主要应用于虚方法(invokevirtual)和接口方法(invokeinterface)。
方法表是动态绑定的核心，也是Java实现动态调用的主要方式，它被存储于方法区中的类型信息。

多态的内存分配过程
1.类的加载
2.实例化子对象，分为this和super两个部分。
this部分包括当前类的实例变量，以及一个指针指向当前类对应的方法区。
super部分包括它的父类的实例变量，以及一个指针指向父类的方法区。
3.用栈内存中的指针变量指向实例对象。

然后invokevirtual在运行时解析会做以下事情：
找到操作数栈顶的第一个元素所指向的对象的实际类型；
如果在该类型（子类）中找到与常量中的描述符和简单名称都相同的方法，进行权限访问，通过则返回这个方法的引用；如果权限访问不通过，则返回java.lang.IllegalAccessError错误。
如果没有找到签名相同的方法，对该类型的父类进行第二步的搜索和验证；
如果没有找到，则返回java.lang.AbstractMethodError.
