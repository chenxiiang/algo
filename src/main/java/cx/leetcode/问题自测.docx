Java基础
Java 中有哪 8 种基本数据类型？它们的默认值和占用的空间大小知道不？ 说说这 8 种基本数据类型对应的包装类型。
💡 提示：Java 中有 8 种基本数据类型，分别为：
6 种数字类型 ：byte、short、int、long、float、double
1 种字符类型：char
1 种布尔型：boolean。

包装类型的常量池技术了解么？
💡 提示：Java 基本类型的包装类的大部分（Byte,Short,Integer,Long ,Character,Boolean）都实现了常量池技术。
Float和Double没有常量池

🌈 拓展：整型包装类对象之间值的比较应该使用 equals 方法

为什么要有包装类型？

💡 提示： 基本类型有默认值、泛型参数不能是基本类型

什么是自动拆装箱？原理？

💡 提示：基本类型和包装类型之间的互转。装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。

遇到过自动拆箱引发的 NPE 问题吗？

💡 提示：两个常见的场景：

●数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险
●三目运算符使用不当会导致诡异的 NPE 异常 只要一个运算中有不同的类型，涉及到类型转换，则编译器会向下（基本类型）转型，再进行运算。

String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?

💡 提示：可以从可变性、线程安全性、性能这几个角度来回答。

重载和重写的区别？

💡 提示：可以从下面几个角度来回答：

●发生范围  重写发生在运行期 重载发生在编译期
●参数列表
●返回值类型
●异常
●访问修饰符
●发生阶段

== 和 equals() 的区别

💡 提示：== 对于基本类型和引用类型的作用效果是不同的，equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals() 方法存在两种使用情况：

●类没有重写 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。
●类重写了 equals()方法 ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

Java 反射？反射有什么优点/缺点？你是怎么理解反射的（为什么框架需要反射）？springboot怎么利用反射？

💡 提示： 想想你平时使用框架为啥能够如此方便。想想动态代理以及注解和反射之间的关系。

谈谈对 Java 注解的理解，解决了什么问题？

💡 提示： 想想你平时使用框架为啥能够如此方便。另外，需要注意注解的解析依赖于反射机制，务必要提前把反射机制搞懂。

Java 泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？

💡 提示：

●好处：编译期间的类型检测（安全）、可读性更好
●Java 的泛型是伪泛型

泛型的作用：

● 使用泛型可在编译期间进行类型检测。 
● 使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。 
● 泛型可以使用自限定类型如 T extends Comparable 。

泛型的限制一般是由泛型擦除机制导致的。擦除为 Object 后无法进行类型判断

●只能声明不能实例化 T 类型变量。
●泛型参数不能是基本类型。因为基本类型不是 Object 子类，应该用基本类型对应的引用类型代替。
●不能实例化泛型参数的数组。擦除后为 Object 后无法进行类型判断。
●不能实例化泛型数组。（数组必须知道它所持有的元素的具体类型，但是类型擦除违反了数组的这种安全检查的原则）
●泛型无法使用 Instance of 和 getClass() 进行类型判断。
●不能实现两个不同泛型参数的同一接口，擦除后多个父类的桥方法将冲突
●不能使用 static 修饰泛型变量
●......

通配符 ？和常用的泛型 T 之间有什么区别？ T在声明的时候用，？在实例化的时候用

●T 可以用于声明变量或常量而 ? 不行。
●T 一般用于声明泛型类或方法，通配符 ? 一般用于泛型方法的调用代码和形参。
●T 在编译期会被擦除为限定类型或 Object，通配符用于捕获具体类型。

内部类了解吗？匿名内部类了解吗？

内部类分为下面 4 种：
●成员内部类  成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员，因为编译器默认为成员内部类添加了一个指向外部类对象的引用），当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要指定外部类名，外部类.this.成员变量。外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。如果要创建成员内部类的对象，前提是必须存在一个外部类的对象
●静态内部类  有static的成员内部类，不需要依赖于外部类
●局部（方法）内部类  局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
●匿名内部类  一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。在new的时候实现方法

为什么局部内部类和匿名内部类只能访问局部final变量？
因为当方法执行完毕后，局部变量的生命周期也就结束了，但是内部类对象的声明周期可能还没结束，所以内部类会创建一个拷贝（如果局部变量的值在编译期可以确定，则直接在内部类中创建一个拷贝，如果无法确定，则通过构造器传参的方式对拷贝进行初始化赋值），这样解决了声明周期的问题，但是在拷贝时必须保证这两个变量是一样的，如果在内部类的运行中修改了变量的值，则会造成数据不一致，为了解决这个问题，必须限定为final，在对它初始化后就不允许再进行修改，从而保证一致性。

BIO,NIO,AIO 有什么区别?

多态以及多态的底层实现
有 2 种方式来实现多态，一种是编译时多态，另外一种是运行时多态；编译时多态是通过方法的重载来实现的，运行时多态是通过方法的重写来实现的。
1）方法的重载：指的是同一个类中有多个同名的方法，但这些方法有着不同的参数。在编译时就可以确定到底调用哪个方法。
2）方法的重写：子类重写父类中的方法。父类的引用变量不仅可以指向父类的实例对象，还可以指向子类的实例对象。当父类的引用指向子类的对象时，只有在运行时才能确定调用哪个方法。体现出多态、动态链接，向上转型。
3）向上转型：父类对象引用子类对象。
4）动态链接：当父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用； 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。

在编译期间只能通过参数的静态类型进行而非实际类型作为判定依据。但是重写和实现接口的方法，编译期间无法判断，只能在运行时判断。

多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。invokevirtual 和 invokeinterface 用于动态绑定。可以看出，动态绑定主要应用于虚方法(invokevirtual)和接口方法(invokeinterface)。
方法表是动态绑定的核心，也是Java实现动态调用的主要方式，它被存储于方法区中的类型信息。

多态的内存分配过程
1.类的加载
2.实例化子对象，分为this和super两个部分。
this部分包括当前类的实例变量，以及一个指针指向当前类对应的方法区。
super部分包括它的父类的实例变量，以及一个指针指向父类的方法区。
3.用栈内存中的指针变量指向实例对象。

然后invokevirtual在运行时解析会做以下事情：
找到操作数栈顶的第一个元素所指向的对象的实际类型；
如果在该类型（子类）中找到与常量中的描述符和简单名称都相同的方法，进行权限访问，通过则返回这个方法的引用；如果权限访问不通过，则返回java.lang.IllegalAccessError错误。
如果没有找到签名相同的方法，对该类型的父类进行第二步的搜索和验证；
如果没有找到，则返回java.lang.AbstractMethodError.

Java 集合
说说 List,Set,Map 三者的区别？

💡 提示：可以从这些数据结构中的元素是否有序、是否可以重复、存储的元素类型（比如 Map 存储的就是键值对）等方面来回答。

List,Set,Map 在 Java 中分别由哪些对应的实现类？底层的数据结构？

💡 提示：拿 List 来举例， List 的常见实现类以及它们的数据结构 ：

●ArrayList： Object[]数组
●Vector：Object[]数组
●LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)

有哪些集合是线程不安全的？怎么解决呢？

💡 提示：这块比较常问的是 Arraylist 和 Vector（除去线程安全的方面，还有vector扩容时扩展1倍，ArrayList扩展0.5倍） 、HashMap 和 ConcurrentHashMap（高频问题，重要） 。被问到 Vector 的时候， 你紧接着可能会被问到 Arraylist 和 Vector 的区别。被问到 ConcurrentHashMap 的时候，你紧接着就可能会被问到 ConcurrentHashMap 相关的问题比如 ConcurrentHashMap 是如何保证线程安全的。

hashtable,对于null值会抛出异常,而对于null键,则会调用null.hashCode(),而导致空指针异常,而concurrenthashmap则对于null键值对,直接抛出空异常,这也就是为什么他们存入null键值对抛出异常的原因.hashmap在对null键求hash时直接返回0，value也可以为0，但是只能有一个key为0.

为什么不支持null？
ConcurrentHashmap和Hashtable都是线程安全用来做支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。而HashMap是非并发的，可以通过contains(key)来做这个判断。而支持并发的Map在调用m.contains（key）和m.get(key),m很可能已经不同了

HashMap 查询，删除的时间复杂度
💡 提示：理想状态下是O（1），因为对内存来说访问任何地址的时间是一样的，但是要达到理想状态需要很大的空间，所以要在空间和时间进行取舍。
●没有哈希冲突的情况：如果没有碰撞就是理想状态
●转链表的情况：hash的时间是1，最坏情况所有元素在同一个链表，就是O(n)
●链表转红黑树的情况：O(logn)

HashMap 的底层实现
💡 提示：
●JDK1.8 之前 ： 数组和链表
●JDK1.8 之后 ： 多了红黑树

HashMap 的长度为什么是 2 的幂次方
💡 提示：提高运算效率。
前提：为什么要取模？哈希值的范围空间有40亿，不能直接用，要经过取模才能得到数组下标。

答案可以答三点：
1、提高运算效率，根据hashcode求存储位置，就是hashcode%length，特殊情况是如果length是2的n次方，这个取模运算等价于位运算hashcode&(length-1)，是比除法运算快的
2、保证低位所有的位置都可用，2的n次方一定是偶数，减1后的二进制末尾一定是1，这样无论hashcode末尾是0还是1，都可以把内存中末尾是1或0的位置都存储元素，如果不保证2的幂，当长度为奇数时，减1的二进制末尾一定是0，此时内存地址末尾为1的位置永远不会有元素放入，造成空间浪费
3、解决负数问题，hashcode结果是int类型，取值范围是-2^31 ~ 2^31 – 1，对负数取模是比较麻烦的，当使用二进制的位运算时，无论hashcode是正数还是负数，反正length-1一定是正数，那么它的首位一定是0，与运算后结果的首位也一定是0，得到的结果一定是正数。


比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同
💡 提示：
●HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。
●HashSet（基于hashmap的哈希表）、LinkedHashSet（基于linkedhashmap实现的链表和哈希表，linkedhashmap是一个将所有entry节点加入一个双向链表的hashmap） 和 TreeSet（红黑树） 的主要区别在于底层数据结构不同（底层数据结构不同又导致这三者的应用场景不同）。

HashMap 和 Hashtable 的区别？ 多线程、效率、null、初始容量和扩容、底层结构
HashMap 和 HashSet 区别？
HashMap 和 TreeMap 区别？

ConcurrentHashMap 和 Hashtable 的区别？
💡 提示：
●底层数据结构
●实现线程安全的方式的区别

ConcurrentHashMap 线程安全的具体实现方式/底层具体实现
💡 提示：
●JDK 1.7 ：Segment 分段+reentrantlock，每个segment都继承reentrantlock
●JDK 1.8 ： CAS 乐观锁和 synchronized
Cas体现在当数组中当前位置为null，也就是指定位置还没有插入元素时，通过cas来把新node写入数组中对应位置，如果在put的过程中别的线程已经插入了数据导致位置又不为空，则cas失败，返回false，继续寻找位置，整个put的过程不加锁，利用table是volatile的特性。当指定位置不为空时，通过加同步锁来添加节点。而在1.7中，定位到segment后就会把整个segment加锁，即使需要插入的位置暂时是空的，也要加锁。（注意，1.7中如果指定的segment还没有初始化，通过cas来初始化）
注
1.8的锁粒度更小，因为1.7中，segment是根据hashcode的高位来计算的，当segment相同时把整个segment都锁住了，但是它们的hashcode并不一定一样，但是在1.8中取消了segment概念，直接就是node数组，其中的元素就是链表的头结点，锁的时候只锁相同hashcode的头结点，并发度是比1.7的实现更高的。
